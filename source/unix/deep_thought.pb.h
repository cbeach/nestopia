// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: deep_thought.proto

#ifndef PROTOBUF_deep_5fthought_2eproto__INCLUDED
#define PROTOBUF_deep_5fthought_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "nes.pb.h"
// @@protoc_insertion_point(includes)
namespace org {
namespace beachc {
namespace deep_thought {
class MachineState;
class MachineStateDefaultTypeInternal;
extern MachineStateDefaultTypeInternal _MachineState_default_instance_;
class RawRGB32;
class RawRGB32DefaultTypeInternal;
extern RawRGB32DefaultTypeInternal _RawRGB32_default_instance_;
class RegionGraph;
class RegionGraphDefaultTypeInternal;
extern RegionGraphDefaultTypeInternal _RegionGraph_default_instance_;
class Sprite;
class SpriteDefaultTypeInternal;
extern SpriteDefaultTypeInternal _Sprite_default_instance_;
class SpriteList;
class SpriteListDefaultTypeInternal;
extern SpriteListDefaultTypeInternal _SpriteList_default_instance_;
class VideoFrame;
class VideoFrameDefaultTypeInternal;
extern VideoFrameDefaultTypeInternal _VideoFrame_default_instance_;
namespace common {
class DPad;
class DPadDefaultTypeInternal;
extern DPadDefaultTypeInternal _DPad_default_instance_;
class Game;
class GameDefaultTypeInternal;
extern GameDefaultTypeInternal _Game_default_instance_;
class Player;
class PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class Shape;
class ShapeDefaultTypeInternal;
extern ShapeDefaultTypeInternal _Shape_default_instance_;
}  // namespace common
namespace nes {
class NESConsoleState;
class NESConsoleStateDefaultTypeInternal;
extern NESConsoleStateDefaultTypeInternal _NESConsoleState_default_instance_;
class NESControllerState;
class NESControllerStateDefaultTypeInternal;
extern NESControllerStateDefaultTypeInternal _NESControllerState_default_instance_;
class NestopiaControl;
class NestopiaControlDefaultTypeInternal;
extern NestopiaControlDefaultTypeInternal _NestopiaControl_default_instance_;
}  // namespace nes
}  // namespace deep_thought
}  // namespace beachc
}  // namespace org

namespace org {
namespace beachc {
namespace deep_thought {

namespace protobuf_deep_5fthought_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_deep_5fthought_2eproto

// ===================================================================

class VideoFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:org.beachc.deep_thought.VideoFrame) */ {
 public:
  VideoFrame();
  virtual ~VideoFrame();

  VideoFrame(const VideoFrame& from);

  inline VideoFrame& operator=(const VideoFrame& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VideoFrame& default_instance();

  enum DataCase {
    kRawFrame = 1,
    kSpriteList = 2,
    kRegionGraph = 3,
    DATA_NOT_SET = 0,
  };

  static inline const VideoFrame* internal_default_instance() {
    return reinterpret_cast<const VideoFrame*>(
               &_VideoFrame_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(VideoFrame* other);

  // implements Message ----------------------------------------------

  inline VideoFrame* New() const PROTOBUF_FINAL { return New(NULL); }

  VideoFrame* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VideoFrame& from);
  void MergeFrom(const VideoFrame& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VideoFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.beachc.deep_thought.MachineState machine_state = 4;
  bool has_machine_state() const;
  void clear_machine_state();
  static const int kMachineStateFieldNumber = 4;
  const ::org::beachc::deep_thought::MachineState& machine_state() const;
  ::org::beachc::deep_thought::MachineState* mutable_machine_state();
  ::org::beachc::deep_thought::MachineState* release_machine_state();
  void set_allocated_machine_state(::org::beachc::deep_thought::MachineState* machine_state);

  // .org.beachc.deep_thought.RawRGB32 raw_frame = 1;
  bool has_raw_frame() const;
  void clear_raw_frame();
  static const int kRawFrameFieldNumber = 1;
  const ::org::beachc::deep_thought::RawRGB32& raw_frame() const;
  ::org::beachc::deep_thought::RawRGB32* mutable_raw_frame();
  ::org::beachc::deep_thought::RawRGB32* release_raw_frame();
  void set_allocated_raw_frame(::org::beachc::deep_thought::RawRGB32* raw_frame);

  // .org.beachc.deep_thought.SpriteList sprite_list = 2;
  bool has_sprite_list() const;
  void clear_sprite_list();
  static const int kSpriteListFieldNumber = 2;
  const ::org::beachc::deep_thought::SpriteList& sprite_list() const;
  ::org::beachc::deep_thought::SpriteList* mutable_sprite_list();
  ::org::beachc::deep_thought::SpriteList* release_sprite_list();
  void set_allocated_sprite_list(::org::beachc::deep_thought::SpriteList* sprite_list);

  // .org.beachc.deep_thought.RegionGraph region_graph = 3;
  bool has_region_graph() const;
  void clear_region_graph();
  static const int kRegionGraphFieldNumber = 3;
  const ::org::beachc::deep_thought::RegionGraph& region_graph() const;
  ::org::beachc::deep_thought::RegionGraph* mutable_region_graph();
  ::org::beachc::deep_thought::RegionGraph* release_region_graph();
  void set_allocated_region_graph(::org::beachc::deep_thought::RegionGraph* region_graph);

  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:org.beachc.deep_thought.VideoFrame)
 private:
  void set_has_raw_frame();
  void set_has_sprite_list();
  void set_has_region_graph();

  inline bool has_data() const;
  void clear_data();
  inline void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::beachc::deep_thought::MachineState* machine_state_;
  union DataUnion {
    DataUnion() {}
    ::org::beachc::deep_thought::RawRGB32* raw_frame_;
    ::org::beachc::deep_thought::SpriteList* sprite_list_;
    ::org::beachc::deep_thought::RegionGraph* region_graph_;
  } data_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_deep_5fthought_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MachineState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:org.beachc.deep_thought.MachineState) */ {
 public:
  MachineState();
  virtual ~MachineState();

  MachineState(const MachineState& from);

  inline MachineState& operator=(const MachineState& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MachineState& default_instance();

  enum StateCase {
    kNesConsoleState = 1,
    STATE_NOT_SET = 0,
  };

  static inline const MachineState* internal_default_instance() {
    return reinterpret_cast<const MachineState*>(
               &_MachineState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(MachineState* other);

  // implements Message ----------------------------------------------

  inline MachineState* New() const PROTOBUF_FINAL { return New(NULL); }

  MachineState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MachineState& from);
  void MergeFrom(const MachineState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MachineState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.beachc.deep_thought.nes.NESConsoleState nes_console_state = 1;
  bool has_nes_console_state() const;
  void clear_nes_console_state();
  static const int kNesConsoleStateFieldNumber = 1;
  const ::org::beachc::deep_thought::nes::NESConsoleState& nes_console_state() const;
  ::org::beachc::deep_thought::nes::NESConsoleState* mutable_nes_console_state();
  ::org::beachc::deep_thought::nes::NESConsoleState* release_nes_console_state();
  void set_allocated_nes_console_state(::org::beachc::deep_thought::nes::NESConsoleState* nes_console_state);

  StateCase state_case() const;
  // @@protoc_insertion_point(class_scope:org.beachc.deep_thought.MachineState)
 private:
  void set_has_nes_console_state();

  inline bool has_state() const;
  void clear_state();
  inline void clear_has_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union StateUnion {
    StateUnion() {}
    ::org::beachc::deep_thought::nes::NESConsoleState* nes_console_state_;
  } state_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_deep_5fthought_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawRGB32 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:org.beachc.deep_thought.RawRGB32) */ {
 public:
  RawRGB32();
  virtual ~RawRGB32();

  RawRGB32(const RawRGB32& from);

  inline RawRGB32& operator=(const RawRGB32& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RawRGB32& default_instance();

  static inline const RawRGB32* internal_default_instance() {
    return reinterpret_cast<const RawRGB32*>(
               &_RawRGB32_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RawRGB32* other);

  // implements Message ----------------------------------------------

  inline RawRGB32* New() const PROTOBUF_FINAL { return New(NULL); }

  RawRGB32* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RawRGB32& from);
  void MergeFrom(const RawRGB32& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RawRGB32* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // .org.beachc.deep_thought.common.Shape shape = 1;
  bool has_shape() const;
  void clear_shape();
  static const int kShapeFieldNumber = 1;
  const ::org::beachc::deep_thought::common::Shape& shape() const;
  ::org::beachc::deep_thought::common::Shape* mutable_shape();
  ::org::beachc::deep_thought::common::Shape* release_shape();
  void set_allocated_shape(::org::beachc::deep_thought::common::Shape* shape);

  // @@protoc_insertion_point(class_scope:org.beachc.deep_thought.RawRGB32)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::org::beachc::deep_thought::common::Shape* shape_;
  mutable int _cached_size_;
  friend struct protobuf_deep_5fthought_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpriteList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:org.beachc.deep_thought.SpriteList) */ {
 public:
  SpriteList();
  virtual ~SpriteList();

  SpriteList(const SpriteList& from);

  inline SpriteList& operator=(const SpriteList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpriteList& default_instance();

  static inline const SpriteList* internal_default_instance() {
    return reinterpret_cast<const SpriteList*>(
               &_SpriteList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(SpriteList* other);

  // implements Message ----------------------------------------------

  inline SpriteList* New() const PROTOBUF_FINAL { return New(NULL); }

  SpriteList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SpriteList& from);
  void MergeFrom(const SpriteList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SpriteList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .org.beachc.deep_thought.Sprite sprites = 1;
  int sprites_size() const;
  void clear_sprites();
  static const int kSpritesFieldNumber = 1;
  const ::org::beachc::deep_thought::Sprite& sprites(int index) const;
  ::org::beachc::deep_thought::Sprite* mutable_sprites(int index);
  ::org::beachc::deep_thought::Sprite* add_sprites();
  ::google::protobuf::RepeatedPtrField< ::org::beachc::deep_thought::Sprite >*
      mutable_sprites();
  const ::google::protobuf::RepeatedPtrField< ::org::beachc::deep_thought::Sprite >&
      sprites() const;

  // @@protoc_insertion_point(class_scope:org.beachc.deep_thought.SpriteList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::org::beachc::deep_thought::Sprite > sprites_;
  mutable int _cached_size_;
  friend struct protobuf_deep_5fthought_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sprite : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:org.beachc.deep_thought.Sprite) */ {
 public:
  Sprite();
  virtual ~Sprite();

  Sprite(const Sprite& from);

  inline Sprite& operator=(const Sprite& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sprite& default_instance();

  static inline const Sprite* internal_default_instance() {
    return reinterpret_cast<const Sprite*>(
               &_Sprite_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Sprite* other);

  // implements Message ----------------------------------------------

  inline Sprite* New() const PROTOBUF_FINAL { return New(NULL); }

  Sprite* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Sprite& from);
  void MergeFrom(const Sprite& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Sprite* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.beachc.deep_thought.common.Shape shape = 1;
  bool has_shape() const;
  void clear_shape();
  static const int kShapeFieldNumber = 1;
  const ::org::beachc::deep_thought::common::Shape& shape() const;
  ::org::beachc::deep_thought::common::Shape* mutable_shape();
  ::org::beachc::deep_thought::common::Shape* release_shape();
  void set_allocated_shape(::org::beachc::deep_thought::common::Shape* shape);

  // @@protoc_insertion_point(class_scope:org.beachc.deep_thought.Sprite)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::beachc::deep_thought::common::Shape* shape_;
  mutable int _cached_size_;
  friend struct protobuf_deep_5fthought_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegionGraph : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:org.beachc.deep_thought.RegionGraph) */ {
 public:
  RegionGraph();
  virtual ~RegionGraph();

  RegionGraph(const RegionGraph& from);

  inline RegionGraph& operator=(const RegionGraph& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionGraph& default_instance();

  static inline const RegionGraph* internal_default_instance() {
    return reinterpret_cast<const RegionGraph*>(
               &_RegionGraph_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(RegionGraph* other);

  // implements Message ----------------------------------------------

  inline RegionGraph* New() const PROTOBUF_FINAL { return New(NULL); }

  RegionGraph* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegionGraph& from);
  void MergeFrom(const RegionGraph& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegionGraph* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:org.beachc.deep_thought.RegionGraph)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_deep_5fthought_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// VideoFrame

// .org.beachc.deep_thought.RawRGB32 raw_frame = 1;
inline bool VideoFrame::has_raw_frame() const {
  return data_case() == kRawFrame;
}
inline void VideoFrame::set_has_raw_frame() {
  _oneof_case_[0] = kRawFrame;
}
inline void VideoFrame::clear_raw_frame() {
  if (has_raw_frame()) {
    delete data_.raw_frame_;
    clear_has_data();
  }
}
inline  const ::org::beachc::deep_thought::RawRGB32& VideoFrame::raw_frame() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.VideoFrame.raw_frame)
  return has_raw_frame()
      ? *data_.raw_frame_
      : ::org::beachc::deep_thought::RawRGB32::default_instance();
}
inline ::org::beachc::deep_thought::RawRGB32* VideoFrame::mutable_raw_frame() {
  if (!has_raw_frame()) {
    clear_data();
    set_has_raw_frame();
    data_.raw_frame_ = new ::org::beachc::deep_thought::RawRGB32;
  }
  // @@protoc_insertion_point(field_mutable:org.beachc.deep_thought.VideoFrame.raw_frame)
  return data_.raw_frame_;
}
inline ::org::beachc::deep_thought::RawRGB32* VideoFrame::release_raw_frame() {
  // @@protoc_insertion_point(field_release:org.beachc.deep_thought.VideoFrame.raw_frame)
  if (has_raw_frame()) {
    clear_has_data();
    ::org::beachc::deep_thought::RawRGB32* temp = data_.raw_frame_;
    data_.raw_frame_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void VideoFrame::set_allocated_raw_frame(::org::beachc::deep_thought::RawRGB32* raw_frame) {
  clear_data();
  if (raw_frame) {
    set_has_raw_frame();
    data_.raw_frame_ = raw_frame;
  }
  // @@protoc_insertion_point(field_set_allocated:org.beachc.deep_thought.VideoFrame.raw_frame)
}

// .org.beachc.deep_thought.SpriteList sprite_list = 2;
inline bool VideoFrame::has_sprite_list() const {
  return data_case() == kSpriteList;
}
inline void VideoFrame::set_has_sprite_list() {
  _oneof_case_[0] = kSpriteList;
}
inline void VideoFrame::clear_sprite_list() {
  if (has_sprite_list()) {
    delete data_.sprite_list_;
    clear_has_data();
  }
}
inline  const ::org::beachc::deep_thought::SpriteList& VideoFrame::sprite_list() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.VideoFrame.sprite_list)
  return has_sprite_list()
      ? *data_.sprite_list_
      : ::org::beachc::deep_thought::SpriteList::default_instance();
}
inline ::org::beachc::deep_thought::SpriteList* VideoFrame::mutable_sprite_list() {
  if (!has_sprite_list()) {
    clear_data();
    set_has_sprite_list();
    data_.sprite_list_ = new ::org::beachc::deep_thought::SpriteList;
  }
  // @@protoc_insertion_point(field_mutable:org.beachc.deep_thought.VideoFrame.sprite_list)
  return data_.sprite_list_;
}
inline ::org::beachc::deep_thought::SpriteList* VideoFrame::release_sprite_list() {
  // @@protoc_insertion_point(field_release:org.beachc.deep_thought.VideoFrame.sprite_list)
  if (has_sprite_list()) {
    clear_has_data();
    ::org::beachc::deep_thought::SpriteList* temp = data_.sprite_list_;
    data_.sprite_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void VideoFrame::set_allocated_sprite_list(::org::beachc::deep_thought::SpriteList* sprite_list) {
  clear_data();
  if (sprite_list) {
    set_has_sprite_list();
    data_.sprite_list_ = sprite_list;
  }
  // @@protoc_insertion_point(field_set_allocated:org.beachc.deep_thought.VideoFrame.sprite_list)
}

// .org.beachc.deep_thought.RegionGraph region_graph = 3;
inline bool VideoFrame::has_region_graph() const {
  return data_case() == kRegionGraph;
}
inline void VideoFrame::set_has_region_graph() {
  _oneof_case_[0] = kRegionGraph;
}
inline void VideoFrame::clear_region_graph() {
  if (has_region_graph()) {
    delete data_.region_graph_;
    clear_has_data();
  }
}
inline  const ::org::beachc::deep_thought::RegionGraph& VideoFrame::region_graph() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.VideoFrame.region_graph)
  return has_region_graph()
      ? *data_.region_graph_
      : ::org::beachc::deep_thought::RegionGraph::default_instance();
}
inline ::org::beachc::deep_thought::RegionGraph* VideoFrame::mutable_region_graph() {
  if (!has_region_graph()) {
    clear_data();
    set_has_region_graph();
    data_.region_graph_ = new ::org::beachc::deep_thought::RegionGraph;
  }
  // @@protoc_insertion_point(field_mutable:org.beachc.deep_thought.VideoFrame.region_graph)
  return data_.region_graph_;
}
inline ::org::beachc::deep_thought::RegionGraph* VideoFrame::release_region_graph() {
  // @@protoc_insertion_point(field_release:org.beachc.deep_thought.VideoFrame.region_graph)
  if (has_region_graph()) {
    clear_has_data();
    ::org::beachc::deep_thought::RegionGraph* temp = data_.region_graph_;
    data_.region_graph_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void VideoFrame::set_allocated_region_graph(::org::beachc::deep_thought::RegionGraph* region_graph) {
  clear_data();
  if (region_graph) {
    set_has_region_graph();
    data_.region_graph_ = region_graph;
  }
  // @@protoc_insertion_point(field_set_allocated:org.beachc.deep_thought.VideoFrame.region_graph)
}

// .org.beachc.deep_thought.MachineState machine_state = 4;
inline bool VideoFrame::has_machine_state() const {
  return this != internal_default_instance() && machine_state_ != NULL;
}
inline void VideoFrame::clear_machine_state() {
  if (GetArenaNoVirtual() == NULL && machine_state_ != NULL) delete machine_state_;
  machine_state_ = NULL;
}
inline const ::org::beachc::deep_thought::MachineState& VideoFrame::machine_state() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.VideoFrame.machine_state)
  return machine_state_ != NULL ? *machine_state_
                         : *::org::beachc::deep_thought::MachineState::internal_default_instance();
}
inline ::org::beachc::deep_thought::MachineState* VideoFrame::mutable_machine_state() {
  
  if (machine_state_ == NULL) {
    machine_state_ = new ::org::beachc::deep_thought::MachineState;
  }
  // @@protoc_insertion_point(field_mutable:org.beachc.deep_thought.VideoFrame.machine_state)
  return machine_state_;
}
inline ::org::beachc::deep_thought::MachineState* VideoFrame::release_machine_state() {
  // @@protoc_insertion_point(field_release:org.beachc.deep_thought.VideoFrame.machine_state)
  
  ::org::beachc::deep_thought::MachineState* temp = machine_state_;
  machine_state_ = NULL;
  return temp;
}
inline void VideoFrame::set_allocated_machine_state(::org::beachc::deep_thought::MachineState* machine_state) {
  delete machine_state_;
  machine_state_ = machine_state;
  if (machine_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:org.beachc.deep_thought.VideoFrame.machine_state)
}

inline bool VideoFrame::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void VideoFrame::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline VideoFrame::DataCase VideoFrame::data_case() const {
  return VideoFrame::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MachineState

// .org.beachc.deep_thought.nes.NESConsoleState nes_console_state = 1;
inline bool MachineState::has_nes_console_state() const {
  return state_case() == kNesConsoleState;
}
inline void MachineState::set_has_nes_console_state() {
  _oneof_case_[0] = kNesConsoleState;
}
inline void MachineState::clear_nes_console_state() {
  if (has_nes_console_state()) {
    delete state_.nes_console_state_;
    clear_has_state();
  }
}
inline  const ::org::beachc::deep_thought::nes::NESConsoleState& MachineState::nes_console_state() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.MachineState.nes_console_state)
  return has_nes_console_state()
      ? *state_.nes_console_state_
      : ::org::beachc::deep_thought::nes::NESConsoleState::default_instance();
}
inline ::org::beachc::deep_thought::nes::NESConsoleState* MachineState::mutable_nes_console_state() {
  if (!has_nes_console_state()) {
    clear_state();
    set_has_nes_console_state();
    state_.nes_console_state_ = new ::org::beachc::deep_thought::nes::NESConsoleState;
  }
  // @@protoc_insertion_point(field_mutable:org.beachc.deep_thought.MachineState.nes_console_state)
  return state_.nes_console_state_;
}
inline ::org::beachc::deep_thought::nes::NESConsoleState* MachineState::release_nes_console_state() {
  // @@protoc_insertion_point(field_release:org.beachc.deep_thought.MachineState.nes_console_state)
  if (has_nes_console_state()) {
    clear_has_state();
    ::org::beachc::deep_thought::nes::NESConsoleState* temp = state_.nes_console_state_;
    state_.nes_console_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MachineState::set_allocated_nes_console_state(::org::beachc::deep_thought::nes::NESConsoleState* nes_console_state) {
  clear_state();
  if (nes_console_state) {
    set_has_nes_console_state();
    state_.nes_console_state_ = nes_console_state;
  }
  // @@protoc_insertion_point(field_set_allocated:org.beachc.deep_thought.MachineState.nes_console_state)
}

inline bool MachineState::has_state() const {
  return state_case() != STATE_NOT_SET;
}
inline void MachineState::clear_has_state() {
  _oneof_case_[0] = STATE_NOT_SET;
}
inline MachineState::StateCase MachineState::state_case() const {
  return MachineState::StateCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RawRGB32

// .org.beachc.deep_thought.common.Shape shape = 1;
inline bool RawRGB32::has_shape() const {
  return this != internal_default_instance() && shape_ != NULL;
}
inline void RawRGB32::clear_shape() {
  if (GetArenaNoVirtual() == NULL && shape_ != NULL) delete shape_;
  shape_ = NULL;
}
inline const ::org::beachc::deep_thought::common::Shape& RawRGB32::shape() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.RawRGB32.shape)
  return shape_ != NULL ? *shape_
                         : *::org::beachc::deep_thought::common::Shape::internal_default_instance();
}
inline ::org::beachc::deep_thought::common::Shape* RawRGB32::mutable_shape() {
  
  if (shape_ == NULL) {
    shape_ = new ::org::beachc::deep_thought::common::Shape;
  }
  // @@protoc_insertion_point(field_mutable:org.beachc.deep_thought.RawRGB32.shape)
  return shape_;
}
inline ::org::beachc::deep_thought::common::Shape* RawRGB32::release_shape() {
  // @@protoc_insertion_point(field_release:org.beachc.deep_thought.RawRGB32.shape)
  
  ::org::beachc::deep_thought::common::Shape* temp = shape_;
  shape_ = NULL;
  return temp;
}
inline void RawRGB32::set_allocated_shape(::org::beachc::deep_thought::common::Shape* shape) {
  delete shape_;
  shape_ = shape;
  if (shape) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:org.beachc.deep_thought.RawRGB32.shape)
}

// bytes data = 2;
inline void RawRGB32::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawRGB32::data() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.RawRGB32.data)
  return data_.GetNoArena();
}
inline void RawRGB32::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.RawRGB32.data)
}
#if LANG_CXX11
inline void RawRGB32::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:org.beachc.deep_thought.RawRGB32.data)
}
#endif
inline void RawRGB32::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:org.beachc.deep_thought.RawRGB32.data)
}
inline void RawRGB32::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:org.beachc.deep_thought.RawRGB32.data)
}
inline ::std::string* RawRGB32::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:org.beachc.deep_thought.RawRGB32.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawRGB32::release_data() {
  // @@protoc_insertion_point(field_release:org.beachc.deep_thought.RawRGB32.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawRGB32::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:org.beachc.deep_thought.RawRGB32.data)
}

// -------------------------------------------------------------------

// SpriteList

// repeated .org.beachc.deep_thought.Sprite sprites = 1;
inline int SpriteList::sprites_size() const {
  return sprites_.size();
}
inline void SpriteList::clear_sprites() {
  sprites_.Clear();
}
inline const ::org::beachc::deep_thought::Sprite& SpriteList::sprites(int index) const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.SpriteList.sprites)
  return sprites_.Get(index);
}
inline ::org::beachc::deep_thought::Sprite* SpriteList::mutable_sprites(int index) {
  // @@protoc_insertion_point(field_mutable:org.beachc.deep_thought.SpriteList.sprites)
  return sprites_.Mutable(index);
}
inline ::org::beachc::deep_thought::Sprite* SpriteList::add_sprites() {
  // @@protoc_insertion_point(field_add:org.beachc.deep_thought.SpriteList.sprites)
  return sprites_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::org::beachc::deep_thought::Sprite >*
SpriteList::mutable_sprites() {
  // @@protoc_insertion_point(field_mutable_list:org.beachc.deep_thought.SpriteList.sprites)
  return &sprites_;
}
inline const ::google::protobuf::RepeatedPtrField< ::org::beachc::deep_thought::Sprite >&
SpriteList::sprites() const {
  // @@protoc_insertion_point(field_list:org.beachc.deep_thought.SpriteList.sprites)
  return sprites_;
}

// -------------------------------------------------------------------

// Sprite

// .org.beachc.deep_thought.common.Shape shape = 1;
inline bool Sprite::has_shape() const {
  return this != internal_default_instance() && shape_ != NULL;
}
inline void Sprite::clear_shape() {
  if (GetArenaNoVirtual() == NULL && shape_ != NULL) delete shape_;
  shape_ = NULL;
}
inline const ::org::beachc::deep_thought::common::Shape& Sprite::shape() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.Sprite.shape)
  return shape_ != NULL ? *shape_
                         : *::org::beachc::deep_thought::common::Shape::internal_default_instance();
}
inline ::org::beachc::deep_thought::common::Shape* Sprite::mutable_shape() {
  
  if (shape_ == NULL) {
    shape_ = new ::org::beachc::deep_thought::common::Shape;
  }
  // @@protoc_insertion_point(field_mutable:org.beachc.deep_thought.Sprite.shape)
  return shape_;
}
inline ::org::beachc::deep_thought::common::Shape* Sprite::release_shape() {
  // @@protoc_insertion_point(field_release:org.beachc.deep_thought.Sprite.shape)
  
  ::org::beachc::deep_thought::common::Shape* temp = shape_;
  shape_ = NULL;
  return temp;
}
inline void Sprite::set_allocated_shape(::org::beachc::deep_thought::common::Shape* shape) {
  delete shape_;
  shape_ = shape;
  if (shape) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:org.beachc.deep_thought.Sprite.shape)
}

// -------------------------------------------------------------------

// RegionGraph

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace deep_thought
}  // namespace beachc
}  // namespace org

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_deep_5fthought_2eproto__INCLUDED
