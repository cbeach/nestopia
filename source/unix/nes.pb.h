// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nes.proto

#ifndef PROTOBUF_nes_2eproto__INCLUDED
#define PROTOBUF_nes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
namespace org {
namespace beachc {
namespace deep_thought {
namespace common {
class DPad;
class DPadDefaultTypeInternal;
extern DPadDefaultTypeInternal _DPad_default_instance_;
class Game;
class GameDefaultTypeInternal;
extern GameDefaultTypeInternal _Game_default_instance_;
class Player;
class PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class Shape;
class ShapeDefaultTypeInternal;
extern ShapeDefaultTypeInternal _Shape_default_instance_;
}  // namespace common
namespace nes {
class NESConsoleState;
class NESConsoleStateDefaultTypeInternal;
extern NESConsoleStateDefaultTypeInternal _NESConsoleState_default_instance_;
class NESControllerState;
class NESControllerStateDefaultTypeInternal;
extern NESControllerStateDefaultTypeInternal _NESControllerState_default_instance_;
class NestopiaControl;
class NestopiaControlDefaultTypeInternal;
extern NestopiaControlDefaultTypeInternal _NestopiaControl_default_instance_;
}  // namespace nes
}  // namespace deep_thought
}  // namespace beachc
}  // namespace org

namespace org {
namespace beachc {
namespace deep_thought {
namespace nes {

namespace protobuf_nes_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_nes_2eproto

// ===================================================================

class NESConsoleState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:org.beachc.deep_thought.nes.NESConsoleState) */ {
 public:
  NESConsoleState();
  virtual ~NESConsoleState();

  NESConsoleState(const NESConsoleState& from);

  inline NESConsoleState& operator=(const NESConsoleState& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NESConsoleState& default_instance();

  static inline const NESConsoleState* internal_default_instance() {
    return reinterpret_cast<const NESConsoleState*>(
               &_NESConsoleState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(NESConsoleState* other);

  // implements Message ----------------------------------------------

  inline NESConsoleState* New() const PROTOBUF_FINAL { return New(NULL); }

  NESConsoleState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NESConsoleState& from);
  void MergeFrom(const NESConsoleState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NESConsoleState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.beachc.deep_thought.nes.NESControllerState player1_input = 1;
  bool has_player1_input() const;
  void clear_player1_input();
  static const int kPlayer1InputFieldNumber = 1;
  const ::org::beachc::deep_thought::nes::NESControllerState& player1_input() const;
  ::org::beachc::deep_thought::nes::NESControllerState* mutable_player1_input();
  ::org::beachc::deep_thought::nes::NESControllerState* release_player1_input();
  void set_allocated_player1_input(::org::beachc::deep_thought::nes::NESControllerState* player1_input);

  // .org.beachc.deep_thought.nes.NESControllerState player2_input = 2;
  bool has_player2_input() const;
  void clear_player2_input();
  static const int kPlayer2InputFieldNumber = 2;
  const ::org::beachc::deep_thought::nes::NESControllerState& player2_input() const;
  ::org::beachc::deep_thought::nes::NESControllerState* mutable_player2_input();
  ::org::beachc::deep_thought::nes::NESControllerState* release_player2_input();
  void set_allocated_player2_input(::org::beachc::deep_thought::nes::NESControllerState* player2_input);

  // .org.beachc.deep_thought.common.Game game = 6;
  bool has_game() const;
  void clear_game();
  static const int kGameFieldNumber = 6;
  const ::org::beachc::deep_thought::common::Game& game() const;
  ::org::beachc::deep_thought::common::Game* mutable_game();
  ::org::beachc::deep_thought::common::Game* release_game();
  void set_allocated_game(::org::beachc::deep_thought::common::Game* game);

  // bool power = 3;
  void clear_power();
  static const int kPowerFieldNumber = 3;
  bool power() const;
  void set_power(bool value);

  // bool reset = 4;
  void clear_reset();
  static const int kResetFieldNumber = 4;
  bool reset() const;
  void set_reset(bool value);

  // bool insertGame = 5;
  void clear_insertgame();
  static const int kInsertGameFieldNumber = 5;
  bool insertgame() const;
  void set_insertgame(bool value);

  // @@protoc_insertion_point(class_scope:org.beachc.deep_thought.nes.NESConsoleState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::beachc::deep_thought::nes::NESControllerState* player1_input_;
  ::org::beachc::deep_thought::nes::NESControllerState* player2_input_;
  ::org::beachc::deep_thought::common::Game* game_;
  bool power_;
  bool reset_;
  bool insertgame_;
  mutable int _cached_size_;
  friend struct protobuf_nes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NESControllerState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:org.beachc.deep_thought.nes.NESControllerState) */ {
 public:
  NESControllerState();
  virtual ~NESControllerState();

  NESControllerState(const NESControllerState& from);

  inline NESControllerState& operator=(const NESControllerState& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NESControllerState& default_instance();

  static inline const NESControllerState* internal_default_instance() {
    return reinterpret_cast<const NESControllerState*>(
               &_NESControllerState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(NESControllerState* other);

  // implements Message ----------------------------------------------

  inline NESControllerState* New() const PROTOBUF_FINAL { return New(NULL); }

  NESControllerState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NESControllerState& from);
  void MergeFrom(const NESControllerState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NESControllerState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .org.beachc.deep_thought.common.DPad dpad = 1;
  bool has_dpad() const;
  void clear_dpad();
  static const int kDpadFieldNumber = 1;
  const ::org::beachc::deep_thought::common::DPad& dpad() const;
  ::org::beachc::deep_thought::common::DPad* mutable_dpad();
  ::org::beachc::deep_thought::common::DPad* release_dpad();
  void set_allocated_dpad(::org::beachc::deep_thought::common::DPad* dpad);

  // .org.beachc.deep_thought.common.Player player = 8;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 8;
  const ::org::beachc::deep_thought::common::Player& player() const;
  ::org::beachc::deep_thought::common::Player* mutable_player();
  ::org::beachc::deep_thought::common::Player* release_player();
  void set_allocated_player(::org::beachc::deep_thought::common::Player* player);

  // bool select = 2;
  void clear_select();
  static const int kSelectFieldNumber = 2;
  bool select() const;
  void set_select(bool value);

  // bool start = 3;
  void clear_start();
  static const int kStartFieldNumber = 3;
  bool start() const;
  void set_start(bool value);

  // bool a = 4;
  void clear_a();
  static const int kAFieldNumber = 4;
  bool a() const;
  void set_a(bool value);

  // bool b = 5;
  void clear_b();
  static const int kBFieldNumber = 5;
  bool b() const;
  void set_b(bool value);

  // bool trurboA = 6;
  void clear_trurboa();
  static const int kTrurboAFieldNumber = 6;
  bool trurboa() const;
  void set_trurboa(bool value);

  // bool trurboB = 7;
  void clear_trurbob();
  static const int kTrurboBFieldNumber = 7;
  bool trurbob() const;
  void set_trurbob(bool value);

  // @@protoc_insertion_point(class_scope:org.beachc.deep_thought.nes.NESControllerState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::org::beachc::deep_thought::common::DPad* dpad_;
  ::org::beachc::deep_thought::common::Player* player_;
  bool select_;
  bool start_;
  bool a_;
  bool b_;
  bool trurboa_;
  bool trurbob_;
  mutable int _cached_size_;
  friend struct protobuf_nes_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NestopiaControl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:org.beachc.deep_thought.nes.NestopiaControl) */ {
 public:
  NestopiaControl();
  virtual ~NestopiaControl();

  NestopiaControl(const NestopiaControl& from);

  inline NestopiaControl& operator=(const NestopiaControl& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NestopiaControl& default_instance();

  static inline const NestopiaControl* internal_default_instance() {
    return reinterpret_cast<const NestopiaControl*>(
               &_NestopiaControl_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(NestopiaControl* other);

  // implements Message ----------------------------------------------

  inline NestopiaControl* New() const PROTOBUF_FINAL { return New(NULL); }

  NestopiaControl* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NestopiaControl& from);
  void MergeFrom(const NestopiaControl& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NestopiaControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool altspeed = 1;
  void clear_altspeed();
  static const int kAltspeedFieldNumber = 1;
  bool altspeed() const;
  void set_altspeed(bool value);

  // bool insertcoin1 = 2;
  void clear_insertcoin1();
  static const int kInsertcoin1FieldNumber = 2;
  bool insertcoin1() const;
  void set_insertcoin1(bool value);

  // bool insertcoin2 = 3;
  void clear_insertcoin2();
  static const int kInsertcoin2FieldNumber = 3;
  bool insertcoin2() const;
  void set_insertcoin2(bool value);

  // bool fdsflip = 4;
  void clear_fdsflip();
  static const int kFdsflipFieldNumber = 4;
  bool fdsflip() const;
  void set_fdsflip(bool value);

  // bool fdsswitch = 5;
  void clear_fdsswitch();
  static const int kFdsswitchFieldNumber = 5;
  bool fdsswitch() const;
  void set_fdsswitch(bool value);

  // bool qsave1 = 6;
  void clear_qsave1();
  static const int kQsave1FieldNumber = 6;
  bool qsave1() const;
  void set_qsave1(bool value);

  // bool qsave2 = 7;
  void clear_qsave2();
  static const int kQsave2FieldNumber = 7;
  bool qsave2() const;
  void set_qsave2(bool value);

  // bool qload1 = 8;
  void clear_qload1();
  static const int kQload1FieldNumber = 8;
  bool qload1() const;
  void set_qload1(bool value);

  // bool qload2 = 9;
  void clear_qload2();
  static const int kQload2FieldNumber = 9;
  bool qload2() const;
  void set_qload2(bool value);

  // bool screenshot = 10;
  void clear_screenshot();
  static const int kScreenshotFieldNumber = 10;
  bool screenshot() const;
  void set_screenshot(bool value);

  // bool reset = 11;
  void clear_reset();
  static const int kResetFieldNumber = 11;
  bool reset() const;
  void set_reset(bool value);

  // bool rwstart = 12;
  void clear_rwstart();
  static const int kRwstartFieldNumber = 12;
  bool rwstart() const;
  void set_rwstart(bool value);

  // bool rwstop = 13;
  void clear_rwstop();
  static const int kRwstopFieldNumber = 13;
  bool rwstop() const;
  void set_rwstop(bool value);

  // bool fullscreen = 14;
  void clear_fullscreen();
  static const int kFullscreenFieldNumber = 14;
  bool fullscreen() const;
  void set_fullscreen(bool value);

  // bool filter = 15;
  void clear_filter();
  static const int kFilterFieldNumber = 15;
  bool filter() const;
  void set_filter(bool value);

  // bool scalefactor = 16;
  void clear_scalefactor();
  static const int kScalefactorFieldNumber = 16;
  bool scalefactor() const;
  void set_scalefactor(bool value);

  // bool quit = 17;
  void clear_quit();
  static const int kQuitFieldNumber = 17;
  bool quit() const;
  void set_quit(bool value);

  // @@protoc_insertion_point(class_scope:org.beachc.deep_thought.nes.NestopiaControl)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool altspeed_;
  bool insertcoin1_;
  bool insertcoin2_;
  bool fdsflip_;
  bool fdsswitch_;
  bool qsave1_;
  bool qsave2_;
  bool qload1_;
  bool qload2_;
  bool screenshot_;
  bool reset_;
  bool rwstart_;
  bool rwstop_;
  bool fullscreen_;
  bool filter_;
  bool scalefactor_;
  bool quit_;
  mutable int _cached_size_;
  friend struct protobuf_nes_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// NESConsoleState

// .org.beachc.deep_thought.nes.NESControllerState player1_input = 1;
inline bool NESConsoleState::has_player1_input() const {
  return this != internal_default_instance() && player1_input_ != NULL;
}
inline void NESConsoleState::clear_player1_input() {
  if (GetArenaNoVirtual() == NULL && player1_input_ != NULL) delete player1_input_;
  player1_input_ = NULL;
}
inline const ::org::beachc::deep_thought::nes::NESControllerState& NESConsoleState::player1_input() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NESConsoleState.player1_input)
  return player1_input_ != NULL ? *player1_input_
                         : *::org::beachc::deep_thought::nes::NESControllerState::internal_default_instance();
}
inline ::org::beachc::deep_thought::nes::NESControllerState* NESConsoleState::mutable_player1_input() {
  
  if (player1_input_ == NULL) {
    player1_input_ = new ::org::beachc::deep_thought::nes::NESControllerState;
  }
  // @@protoc_insertion_point(field_mutable:org.beachc.deep_thought.nes.NESConsoleState.player1_input)
  return player1_input_;
}
inline ::org::beachc::deep_thought::nes::NESControllerState* NESConsoleState::release_player1_input() {
  // @@protoc_insertion_point(field_release:org.beachc.deep_thought.nes.NESConsoleState.player1_input)
  
  ::org::beachc::deep_thought::nes::NESControllerState* temp = player1_input_;
  player1_input_ = NULL;
  return temp;
}
inline void NESConsoleState::set_allocated_player1_input(::org::beachc::deep_thought::nes::NESControllerState* player1_input) {
  delete player1_input_;
  player1_input_ = player1_input;
  if (player1_input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:org.beachc.deep_thought.nes.NESConsoleState.player1_input)
}

// .org.beachc.deep_thought.nes.NESControllerState player2_input = 2;
inline bool NESConsoleState::has_player2_input() const {
  return this != internal_default_instance() && player2_input_ != NULL;
}
inline void NESConsoleState::clear_player2_input() {
  if (GetArenaNoVirtual() == NULL && player2_input_ != NULL) delete player2_input_;
  player2_input_ = NULL;
}
inline const ::org::beachc::deep_thought::nes::NESControllerState& NESConsoleState::player2_input() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NESConsoleState.player2_input)
  return player2_input_ != NULL ? *player2_input_
                         : *::org::beachc::deep_thought::nes::NESControllerState::internal_default_instance();
}
inline ::org::beachc::deep_thought::nes::NESControllerState* NESConsoleState::mutable_player2_input() {
  
  if (player2_input_ == NULL) {
    player2_input_ = new ::org::beachc::deep_thought::nes::NESControllerState;
  }
  // @@protoc_insertion_point(field_mutable:org.beachc.deep_thought.nes.NESConsoleState.player2_input)
  return player2_input_;
}
inline ::org::beachc::deep_thought::nes::NESControllerState* NESConsoleState::release_player2_input() {
  // @@protoc_insertion_point(field_release:org.beachc.deep_thought.nes.NESConsoleState.player2_input)
  
  ::org::beachc::deep_thought::nes::NESControllerState* temp = player2_input_;
  player2_input_ = NULL;
  return temp;
}
inline void NESConsoleState::set_allocated_player2_input(::org::beachc::deep_thought::nes::NESControllerState* player2_input) {
  delete player2_input_;
  player2_input_ = player2_input;
  if (player2_input) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:org.beachc.deep_thought.nes.NESConsoleState.player2_input)
}

// bool power = 3;
inline void NESConsoleState::clear_power() {
  power_ = false;
}
inline bool NESConsoleState::power() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NESConsoleState.power)
  return power_;
}
inline void NESConsoleState::set_power(bool value) {
  
  power_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NESConsoleState.power)
}

// bool reset = 4;
inline void NESConsoleState::clear_reset() {
  reset_ = false;
}
inline bool NESConsoleState::reset() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NESConsoleState.reset)
  return reset_;
}
inline void NESConsoleState::set_reset(bool value) {
  
  reset_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NESConsoleState.reset)
}

// bool insertGame = 5;
inline void NESConsoleState::clear_insertgame() {
  insertgame_ = false;
}
inline bool NESConsoleState::insertgame() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NESConsoleState.insertGame)
  return insertgame_;
}
inline void NESConsoleState::set_insertgame(bool value) {
  
  insertgame_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NESConsoleState.insertGame)
}

// .org.beachc.deep_thought.common.Game game = 6;
inline bool NESConsoleState::has_game() const {
  return this != internal_default_instance() && game_ != NULL;
}
inline void NESConsoleState::clear_game() {
  if (GetArenaNoVirtual() == NULL && game_ != NULL) delete game_;
  game_ = NULL;
}
inline const ::org::beachc::deep_thought::common::Game& NESConsoleState::game() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NESConsoleState.game)
  return game_ != NULL ? *game_
                         : *::org::beachc::deep_thought::common::Game::internal_default_instance();
}
inline ::org::beachc::deep_thought::common::Game* NESConsoleState::mutable_game() {
  
  if (game_ == NULL) {
    game_ = new ::org::beachc::deep_thought::common::Game;
  }
  // @@protoc_insertion_point(field_mutable:org.beachc.deep_thought.nes.NESConsoleState.game)
  return game_;
}
inline ::org::beachc::deep_thought::common::Game* NESConsoleState::release_game() {
  // @@protoc_insertion_point(field_release:org.beachc.deep_thought.nes.NESConsoleState.game)
  
  ::org::beachc::deep_thought::common::Game* temp = game_;
  game_ = NULL;
  return temp;
}
inline void NESConsoleState::set_allocated_game(::org::beachc::deep_thought::common::Game* game) {
  delete game_;
  game_ = game;
  if (game) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:org.beachc.deep_thought.nes.NESConsoleState.game)
}

// -------------------------------------------------------------------

// NESControllerState

// .org.beachc.deep_thought.common.DPad dpad = 1;
inline bool NESControllerState::has_dpad() const {
  return this != internal_default_instance() && dpad_ != NULL;
}
inline void NESControllerState::clear_dpad() {
  if (GetArenaNoVirtual() == NULL && dpad_ != NULL) delete dpad_;
  dpad_ = NULL;
}
inline const ::org::beachc::deep_thought::common::DPad& NESControllerState::dpad() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NESControllerState.dpad)
  return dpad_ != NULL ? *dpad_
                         : *::org::beachc::deep_thought::common::DPad::internal_default_instance();
}
inline ::org::beachc::deep_thought::common::DPad* NESControllerState::mutable_dpad() {
  
  if (dpad_ == NULL) {
    dpad_ = new ::org::beachc::deep_thought::common::DPad;
  }
  // @@protoc_insertion_point(field_mutable:org.beachc.deep_thought.nes.NESControllerState.dpad)
  return dpad_;
}
inline ::org::beachc::deep_thought::common::DPad* NESControllerState::release_dpad() {
  // @@protoc_insertion_point(field_release:org.beachc.deep_thought.nes.NESControllerState.dpad)
  
  ::org::beachc::deep_thought::common::DPad* temp = dpad_;
  dpad_ = NULL;
  return temp;
}
inline void NESControllerState::set_allocated_dpad(::org::beachc::deep_thought::common::DPad* dpad) {
  delete dpad_;
  dpad_ = dpad;
  if (dpad) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:org.beachc.deep_thought.nes.NESControllerState.dpad)
}

// bool select = 2;
inline void NESControllerState::clear_select() {
  select_ = false;
}
inline bool NESControllerState::select() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NESControllerState.select)
  return select_;
}
inline void NESControllerState::set_select(bool value) {
  
  select_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NESControllerState.select)
}

// bool start = 3;
inline void NESControllerState::clear_start() {
  start_ = false;
}
inline bool NESControllerState::start() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NESControllerState.start)
  return start_;
}
inline void NESControllerState::set_start(bool value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NESControllerState.start)
}

// bool a = 4;
inline void NESControllerState::clear_a() {
  a_ = false;
}
inline bool NESControllerState::a() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NESControllerState.a)
  return a_;
}
inline void NESControllerState::set_a(bool value) {
  
  a_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NESControllerState.a)
}

// bool b = 5;
inline void NESControllerState::clear_b() {
  b_ = false;
}
inline bool NESControllerState::b() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NESControllerState.b)
  return b_;
}
inline void NESControllerState::set_b(bool value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NESControllerState.b)
}

// bool trurboA = 6;
inline void NESControllerState::clear_trurboa() {
  trurboa_ = false;
}
inline bool NESControllerState::trurboa() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NESControllerState.trurboA)
  return trurboa_;
}
inline void NESControllerState::set_trurboa(bool value) {
  
  trurboa_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NESControllerState.trurboA)
}

// bool trurboB = 7;
inline void NESControllerState::clear_trurbob() {
  trurbob_ = false;
}
inline bool NESControllerState::trurbob() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NESControllerState.trurboB)
  return trurbob_;
}
inline void NESControllerState::set_trurbob(bool value) {
  
  trurbob_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NESControllerState.trurboB)
}

// .org.beachc.deep_thought.common.Player player = 8;
inline bool NESControllerState::has_player() const {
  return this != internal_default_instance() && player_ != NULL;
}
inline void NESControllerState::clear_player() {
  if (GetArenaNoVirtual() == NULL && player_ != NULL) delete player_;
  player_ = NULL;
}
inline const ::org::beachc::deep_thought::common::Player& NESControllerState::player() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NESControllerState.player)
  return player_ != NULL ? *player_
                         : *::org::beachc::deep_thought::common::Player::internal_default_instance();
}
inline ::org::beachc::deep_thought::common::Player* NESControllerState::mutable_player() {
  
  if (player_ == NULL) {
    player_ = new ::org::beachc::deep_thought::common::Player;
  }
  // @@protoc_insertion_point(field_mutable:org.beachc.deep_thought.nes.NESControllerState.player)
  return player_;
}
inline ::org::beachc::deep_thought::common::Player* NESControllerState::release_player() {
  // @@protoc_insertion_point(field_release:org.beachc.deep_thought.nes.NESControllerState.player)
  
  ::org::beachc::deep_thought::common::Player* temp = player_;
  player_ = NULL;
  return temp;
}
inline void NESControllerState::set_allocated_player(::org::beachc::deep_thought::common::Player* player) {
  delete player_;
  player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:org.beachc.deep_thought.nes.NESControllerState.player)
}

// -------------------------------------------------------------------

// NestopiaControl

// bool altspeed = 1;
inline void NestopiaControl::clear_altspeed() {
  altspeed_ = false;
}
inline bool NestopiaControl::altspeed() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NestopiaControl.altspeed)
  return altspeed_;
}
inline void NestopiaControl::set_altspeed(bool value) {
  
  altspeed_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NestopiaControl.altspeed)
}

// bool insertcoin1 = 2;
inline void NestopiaControl::clear_insertcoin1() {
  insertcoin1_ = false;
}
inline bool NestopiaControl::insertcoin1() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NestopiaControl.insertcoin1)
  return insertcoin1_;
}
inline void NestopiaControl::set_insertcoin1(bool value) {
  
  insertcoin1_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NestopiaControl.insertcoin1)
}

// bool insertcoin2 = 3;
inline void NestopiaControl::clear_insertcoin2() {
  insertcoin2_ = false;
}
inline bool NestopiaControl::insertcoin2() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NestopiaControl.insertcoin2)
  return insertcoin2_;
}
inline void NestopiaControl::set_insertcoin2(bool value) {
  
  insertcoin2_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NestopiaControl.insertcoin2)
}

// bool fdsflip = 4;
inline void NestopiaControl::clear_fdsflip() {
  fdsflip_ = false;
}
inline bool NestopiaControl::fdsflip() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NestopiaControl.fdsflip)
  return fdsflip_;
}
inline void NestopiaControl::set_fdsflip(bool value) {
  
  fdsflip_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NestopiaControl.fdsflip)
}

// bool fdsswitch = 5;
inline void NestopiaControl::clear_fdsswitch() {
  fdsswitch_ = false;
}
inline bool NestopiaControl::fdsswitch() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NestopiaControl.fdsswitch)
  return fdsswitch_;
}
inline void NestopiaControl::set_fdsswitch(bool value) {
  
  fdsswitch_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NestopiaControl.fdsswitch)
}

// bool qsave1 = 6;
inline void NestopiaControl::clear_qsave1() {
  qsave1_ = false;
}
inline bool NestopiaControl::qsave1() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NestopiaControl.qsave1)
  return qsave1_;
}
inline void NestopiaControl::set_qsave1(bool value) {
  
  qsave1_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NestopiaControl.qsave1)
}

// bool qsave2 = 7;
inline void NestopiaControl::clear_qsave2() {
  qsave2_ = false;
}
inline bool NestopiaControl::qsave2() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NestopiaControl.qsave2)
  return qsave2_;
}
inline void NestopiaControl::set_qsave2(bool value) {
  
  qsave2_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NestopiaControl.qsave2)
}

// bool qload1 = 8;
inline void NestopiaControl::clear_qload1() {
  qload1_ = false;
}
inline bool NestopiaControl::qload1() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NestopiaControl.qload1)
  return qload1_;
}
inline void NestopiaControl::set_qload1(bool value) {
  
  qload1_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NestopiaControl.qload1)
}

// bool qload2 = 9;
inline void NestopiaControl::clear_qload2() {
  qload2_ = false;
}
inline bool NestopiaControl::qload2() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NestopiaControl.qload2)
  return qload2_;
}
inline void NestopiaControl::set_qload2(bool value) {
  
  qload2_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NestopiaControl.qload2)
}

// bool screenshot = 10;
inline void NestopiaControl::clear_screenshot() {
  screenshot_ = false;
}
inline bool NestopiaControl::screenshot() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NestopiaControl.screenshot)
  return screenshot_;
}
inline void NestopiaControl::set_screenshot(bool value) {
  
  screenshot_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NestopiaControl.screenshot)
}

// bool reset = 11;
inline void NestopiaControl::clear_reset() {
  reset_ = false;
}
inline bool NestopiaControl::reset() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NestopiaControl.reset)
  return reset_;
}
inline void NestopiaControl::set_reset(bool value) {
  
  reset_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NestopiaControl.reset)
}

// bool rwstart = 12;
inline void NestopiaControl::clear_rwstart() {
  rwstart_ = false;
}
inline bool NestopiaControl::rwstart() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NestopiaControl.rwstart)
  return rwstart_;
}
inline void NestopiaControl::set_rwstart(bool value) {
  
  rwstart_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NestopiaControl.rwstart)
}

// bool rwstop = 13;
inline void NestopiaControl::clear_rwstop() {
  rwstop_ = false;
}
inline bool NestopiaControl::rwstop() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NestopiaControl.rwstop)
  return rwstop_;
}
inline void NestopiaControl::set_rwstop(bool value) {
  
  rwstop_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NestopiaControl.rwstop)
}

// bool fullscreen = 14;
inline void NestopiaControl::clear_fullscreen() {
  fullscreen_ = false;
}
inline bool NestopiaControl::fullscreen() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NestopiaControl.fullscreen)
  return fullscreen_;
}
inline void NestopiaControl::set_fullscreen(bool value) {
  
  fullscreen_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NestopiaControl.fullscreen)
}

// bool filter = 15;
inline void NestopiaControl::clear_filter() {
  filter_ = false;
}
inline bool NestopiaControl::filter() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NestopiaControl.filter)
  return filter_;
}
inline void NestopiaControl::set_filter(bool value) {
  
  filter_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NestopiaControl.filter)
}

// bool scalefactor = 16;
inline void NestopiaControl::clear_scalefactor() {
  scalefactor_ = false;
}
inline bool NestopiaControl::scalefactor() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NestopiaControl.scalefactor)
  return scalefactor_;
}
inline void NestopiaControl::set_scalefactor(bool value) {
  
  scalefactor_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NestopiaControl.scalefactor)
}

// bool quit = 17;
inline void NestopiaControl::clear_quit() {
  quit_ = false;
}
inline bool NestopiaControl::quit() const {
  // @@protoc_insertion_point(field_get:org.beachc.deep_thought.nes.NestopiaControl.quit)
  return quit_;
}
inline void NestopiaControl::set_quit(bool value) {
  
  quit_ = value;
  // @@protoc_insertion_point(field_set:org.beachc.deep_thought.nes.NestopiaControl.quit)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace nes
}  // namespace deep_thought
}  // namespace beachc
}  // namespace org

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_nes_2eproto__INCLUDED
